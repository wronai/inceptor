def generate_config_file(self, technologies: list) -> str:
    """Generuje config.py"""
    return """import os
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    \"\"\"Base configuration\"\"\"
    SECRET_KEY = os.getenv('SECRET_KEY', 'dev-secret-key-change-me')
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    ENV = os.getenv('ENV', 'development')

    # Server configuration
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8000))

    # Database
    DATABASE_URL = os.getenv('DATABASE_URL', 'sqlite:///app.db')

    # Redis
    REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')

    # Logging
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
    LOG_FILE = os.getenv('LOG_FILE', 'app.log')

    # JWT
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', SECRET_KEY)
    JWT_EXPIRATION_HOURS = int(os.getenv('JWT_EXPIRATION_HOURS', 24))

class DevelopmentConfig(Config):
    \"\"\"Development configuration\"\"\"
    DEBUG = True
    LOG_LEVEL = 'DEBUG'

class ProductionConfig(Config):
    \"\"\"Production configuration\"\"\"
    DEBUG = False
    LOG_LEVEL = 'WARNING'

class TestingConfig(Config):
    \"\"\"Testing configuration\"\"\"
    TESTING = True
    DATABASE_URL = 'sqlite:///:memory:'

# Configuration mapping
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}

def get_config():
    \"\"\"Get configuration based on environment\"\"\"
    env = os.getenv('ENV', 'development')
    return config.get(env, config['default'])
"""


def generate_package_json(self, technologies: list) -> str:
    """Generuje package.json dla Node.js projektów"""
    return """{
  "name": "generated-app",
  "version": "1.0.0",
  "description": "Generated by Dream Architect",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest",
    "build": "webpack --mode production"
  },
  "dependencies": {
    "express": "^4.18.2",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}"""


def generate_basic_tests(self, technologies: list) -> str:
    """Generuje podstawowe testy"""
    return """#!/usr/bin/env python3
import unittest
import os
import sys
from pathlib import Path

# Add current directory to path
sys.path.insert(0, str(Path(__file__).parent))

class TestBasicFunctionality(unittest.TestCase):
    \"\"\"Basic functionality tests\"\"\"

    def setUp(self):
        \"\"\"Set up test environment\"\"\"
        os.environ['ENV'] = 'testing'

    def test_environment_setup(self):
        \"\"\"Test that environment is properly configured\"\"\"
        self.assertEqual(os.getenv('ENV'), 'testing')

    def test_config_loading(self):
        \"\"\"Test configuration loading\"\"\"
        try:
            from config import get_config
            config = get_config()
            self.assertIsNotNone(config)
        except ImportError:
            self.skipTest("Config module not found")

    def test_health_check(self):
        \"\"\"Test health check functionality\"\"\"
        try:
            import healthcheck
            # Health check should not raise exceptions
            self.assertTrue(True)
        except ImportError:
            self.skipTest("Health check module not found")

    def test_requirements_file_exists(self):
        \"\"\"Test that requirements.txt exists\"\"\"
        self.assertTrue(Path('requirements.txt').exists())

    def test_env_example_exists(self):
        \"\"\"Test that .env.example exists\"\"\"
        self.assertTrue(Path('.env.example').exists())

if __name__ == '__main__':
    unittest.main()
"""


def generate_k8s_deployment(self) -> str:
    """Generuje Kubernetes deployment"""
    return """apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
  labels:
    app: generated-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: generated-app
  template:
    metadata:
      labels:
        app: generated-app
    spec:
      containers:
      - name: app
        image: generated-app:latest
        ports:
        - containerPort: 8000
        env:
        - name: ENV
          value: "production"
        - name: PORT
          value: "8000"
        envFrom:
        - secretRef:
            name: app-secrets
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: generated-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8000
  type: LoadBalancer
"""


def generate_github_actions(self, technologies: list) -> str:
    """Generuje GitHub Actions CI/CD"""
    return """name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run health check
      run: python healthcheck.py

    - name: Run tests
      run: python -m pytest test_basic.py -v

    - name: Test Docker build
      run: docker build -t test-app .

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Build and push Docker image
      run: |
        echo "Building Docker image..."
        docker build -t ${{ github.repository }}:latest .
        # Add your registry push commands here

    - name: Deploy to production
      run: |
        echo "Deploying to production..."
        # Add your deployment commands here
"""  # !/usr/bin/env python3


"""
Najprostszy Dream Architect System
Minimal implementation z Ollama integration
"""

import json
import requests
from typing import Dict, List
from datetime import datetime


class SimpleDreamArchitect:
    """Minimalny Dream Architect - 3 poziomy: LIMBO → DREAM → REALITY"""

    def __init__(self, ollama_url="http://localhost:11434"):
        self.ollama_url = ollama_url
        self.model = "mistral:7b"

    def ask_ollama(self, prompt: str) -> str:
        """Wysyła prompt do Ollama i zwraca odpowiedź"""
        try:
            response = requests.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": self.model,
                    "prompt": prompt,
                    "stream": False,
                    "options": {"temperature": 0.7}
                }
            )
            return response.json()['response']
        except Exception as e:
            return f"ERROR: {str(e)}"

    def limbo(self, problem: str) -> Dict:
        """LEVEL 1: Meta-Architecture - problem → komponenty"""
        prompt = f"""
        Problem: {problem}

        Analizuj problem i podaj odpowiedź w JSON:
        {{
            "components": ["komponent1", "komponent2", "komponent3"],
            "tasks": [
                {{
                    "name": "task1",
                    "description": "co zrobić"
                }}
            ]
        }}
        """

        response = self.ask_ollama(prompt)
        try:
            # Wyciągnij JSON z odpowiedzi
            start = response.find('{')
            end = response.rfind('}') + 1
            if start != -1 and end > start:
                return json.loads(response[start:end])
        except:
            pass

        # Fallback jeśli JSON nie parsuje
        return {
            "components": ["frontend", "backend", "database"],
            "tasks": [{"name": "design", "description": f"Zaprojektuj rozwiązanie dla: {problem}"}]
        }

    def dream(self, limbo_result: Dict) -> Dict:
        """LEVEL 2: Solution Design - komponenty → technical specs"""
        components = limbo_result.get('components', [])

        prompt = f"""
        Komponenty: {components}

        Zaprojektuj technical solution w JSON:
        {{
            "architecture": "opis architektury",
            "technologies": ["tech1", "tech2"],
            "implementation_tasks": [
                {{
                    "file": "nazwa_pliku",
                    "description": "co implementować"
                }}
            ]
        }}
        """

        response = self.ask_ollama(prompt)
        try:
            start = response.find('{')
            end = response.rfind('}') + 1
            if start != -1 and end > start:
                return json.loads(response[start:end])
        except:
            pass

        return {
            "architecture": f"System wykorzystujący {', '.join(components)}",
            "technologies": ["Python", "JavaScript"],
            "implementation_tasks": [
                {"file": "main.py", "description": "Główna implementacja"},
                {"file": "config.yml", "description": "Konfiguracja"}
            ]
        }

    def reality(self, dream_result: Dict) -> Dict:
        """LEVEL 3: Implementation - specs → kod + environment setup"""
        tasks = dream_result.get('implementation_tasks', [])
        technologies = dream_result.get('technologies', [])
        files = {}

        # Generuj pliki kodu
        for task in tasks:
            file_name = task.get('file', 'main.py')
            description = task.get('description', 'Implementacja')

            prompt = f"""
            Stwórz zawartość pliku: {file_name}
            Opis: {description}
            Technologie: {technologies}

            Wymagania:
            - Production-ready kod z error handling
            - Proper logging i configuration
            - Environment variables support
            - Health checks

            Podaj tylko kod, bez komentarzy markdown:
            """

            code = self.ask_ollama(prompt)
            code = code.replace('```python', '').replace('```', '').strip()
            files[file_name] = code

        # Generuj pliki środowiskowe
        env_files = self.generate_environment_files(dream_result)
        files.update(env_files)

        return {"files": files}

    def generate_environment_files(self, dream_result: Dict) -> Dict:
        """Generuje pliki konfiguracyjne i środowiskowe"""
        technologies = dream_result.get('technologies', [])
        architecture = dream_result.get('architecture', '')

        env_files = {}

        # 1. Docker setup
        if any(tech.lower() in ['python', 'flask', 'django', 'fastapi'] for tech in technologies):
            env_files['Dockerfile'] = self.generate_dockerfile(technologies)
            env_files['docker-compose.yml'] = self.generate_docker_compose(technologies, architecture)

        # 2. Requirements/Dependencies
        if any(tech.lower() in ['python', 'flask', 'django', 'fastapi'] for tech in technologies):
            env_files['requirements.txt'] = self.generate_requirements(technologies)
        elif any(tech.lower() in ['nodejs', 'node', 'javascript', 'react'] for tech in technologies):
            env_files['package.json'] = self.generate_package_json(technologies)

        # 3. Environment configuration
        env_files['.env.example'] = self.generate_env_example(technologies, architecture)
        env_files['config.py'] = self.generate_config_file(technologies)

        # 4. Setup scripts
        env_files['setup.sh'] = self.generate_setup_script(technologies)
        env_files['run.sh'] = self.generate_run_script(technologies)

        # 5. Health check
        env_files['healthcheck.py'] = self.generate_healthcheck(technologies)

        # 6. Testing setup
        env_files['test_basic.py'] = self.generate_basic_tests(technologies)

        # 7. Deployment files
        if 'kubernetes' in [t.lower() for t in technologies] or 'k8s' in architecture.lower():
            env_files['k8s-deployment.yaml'] = self.generate_k8s_deployment()

        # 8. CI/CD
        env_files['.github/workflows/ci.yml'] = self.generate_github_actions(technologies)

        # 9. Documentation
        env_files['TROUBLESHOOTING.md'] = self.generate_troubleshooting(technologies)

        return env_files

    def generate_dockerfile(self, technologies: list) -> str:
        """Generuje Dockerfile na podstawie technologii"""
        if any(tech.lower() in ['python', 'flask', 'django', 'fastapi'] for tech in technologies):
            return """FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash app && chown -R app:app /app
USER app

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD python healthcheck.py

# Run application
CMD ["python", "main.py"]
"""
        return "# Dockerfile - adjust for your technology stack"

    def generate_docker_compose(self, technologies: list, architecture: str) -> str:
        """Generuje docker-compose.yml"""
        has_db = any(db in architecture.lower() for db in ['postgres', 'mysql', 'mongo', 'redis'])

        compose = """version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ENV=development
    env_file:
      - .env
    depends_on:"""

        if has_db:
            if 'postgres' in architecture.lower():
                compose += """
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: ${DB_NAME:-myapp}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped"""

            if 'redis' in architecture.lower():
                compose += """

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    restart: unless-stopped"""

        if has_db:
            compose += """

volumes:
  postgres_data:"""

        return compose

    def generate_requirements(self, technologies: list) -> str:
        """Generuje requirements.txt"""
        base_requirements = []

        for tech in technologies:
            tech_lower = tech.lower()
            if tech_lower == 'flask':
                base_requirements.extend([
                    'Flask==2.3.3',
                    'Flask-SQLAlchemy==3.0.5',
                    'Flask-CORS==4.0.0',
                    'python-dotenv==1.0.0'
                ])
            elif tech_lower == 'fastapi':
                base_requirements.extend([
                    'fastapi==0.104.1',
                    'uvicorn[standard]==0.24.0',
                    'python-dotenv==1.0.0',
                    'pydantic==2.5.0'
                ])
            elif tech_lower in ['postgres', 'postgresql']:
                base_requirements.append('psycopg2-binary==2.9.7')
            elif tech_lower == 'redis':
                base_requirements.append('redis==5.0.1')
            elif tech_lower in ['auth', 'jwt']:
                base_requirements.append('PyJWT==2.8.0')

        # Common dependencies
        base_requirements.extend([
            'requests==2.31.0',
            'python-dotenv==1.0.0',
            'loguru==0.7.2',
            'pytest==7.4.3',
            'pytest-cov==4.1.0'
        ])

        return '\n'.join(sorted(set(base_requirements)))

    def generate_env_example(self, technologies: list, architecture: str) -> str:
        """Generuje .env.example"""
        env_vars = [
            "# Application Configuration",
            "ENV=development",
            "DEBUG=True",
            "SECRET_KEY=your-super-secret-key-change-in-production",
            "PORT=8000",
            "HOST=0.0.0.0",
            "",
            "# Logging",
            "LOG_LEVEL=INFO",
            "LOG_FILE=app.log"
        ]

        if any(db in architecture.lower() for db in ['postgres', 'mysql']):
            env_vars.extend([
                "",
                "# Database Configuration",
                "DB_HOST=localhost",
                "DB_PORT=5432",
                "DB_NAME=myapp",
                "DB_USER=postgres",
                "DB_PASSWORD=postgres",
                "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/myapp"
            ])

        if 'redis' in architecture.lower():
            env_vars.extend([
                "",
                "# Redis Configuration",
                "REDIS_HOST=localhost",
                "REDIS_PORT=6379",
                "REDIS_PASSWORD=",
                "REDIS_URL=redis://localhost:6379/0"
            ])

        if any(auth in technologies for auth in ['jwt', 'auth', 'authentication']):
            env_vars.extend([
                "",
                "# Authentication",
                "JWT_SECRET_KEY=jwt-secret-key-change-me",
                "JWT_EXPIRATION_HOURS=24",
                "PASSWORD_SALT_ROUNDS=12"
            ])

        return '\n'.join(env_vars)

    def generate_setup_script(self, technologies: list) -> str:
        """Generuje skrypt setup.sh"""
        return """#!/bin/bash
set -e

echo "🚀 Setting up the application..."

# Check if Python is installed
if ! command -v python3 &> /dev/null; then
    echo "❌ Python 3 is required but not installed"
    exit 1
fi

# Check if pip is installed
if ! command -v pip &> /dev/null; then
    echo "❌ pip is required but not installed"
    exit 1
fi

# Create virtual environment
if [ ! -d "venv" ]; then
    echo "📦 Creating virtual environment..."
    python3 -m venv venv
fi

# Activate virtual environment
echo "🔧 Activating virtual environment..."
source venv/bin/activate

# Install dependencies
echo "📥 Installing dependencies..."
pip install --upgrade pip
pip install -r requirements.txt

# Copy environment file
if [ ! -f ".env" ]; then
    echo "📝 Creating .env file..."
    cp .env.example .env
    echo "⚠️  Please edit .env file with your configuration"
fi

# Run health check
echo "🏥 Running health check..."
python healthcheck.py

echo "✅ Setup complete!"
echo "Run './run.sh' to start the application"
"""

    def generate_run_script(self, technologies: list) -> str:
        """Generuje skrypt run.sh"""
        if 'flask' in [t.lower() for t in technologies]:
            cmd = "python app.py"
        elif 'fastapi' in [t.lower() for t in technologies]:
            cmd = "uvicorn main:app --host 0.0.0.0 --port 8000 --reload"
        else:
            cmd = "python main.py"

        return f"""#!/bin/bash
set -e

# Load environment variables
if [ -f ".env" ]; then
    export $(cat .env | xargs)
fi

# Activate virtual environment if exists
if [ -d "venv" ]; then
    source venv/bin/activate
fi

echo "🚀 Starting application..."
echo "📍 Environment: ${{ENV:-development}}"
echo "🌐 Port: ${{PORT:-8000}}"

# Run the application
{cmd}
"""

    def generate_healthcheck(self, technologies: list) -> str:
        """Generuje healthcheck.py"""
        return """#!/usr/bin/env python3
import os
import sys
import requests
import time
from pathlib import Path

def check_env_file():
    \"\"\"Check if .env file exists\"\"\"
    if not Path('.env').exists():
        print("❌ .env file not found")
        return False
    print("✅ .env file exists")
    return True

def check_dependencies():
    \"\"\"Check if all dependencies are installed\"\"\"
    try:
        import requests
        print("✅ Dependencies installed")
        return True
    except ImportError as e:
        print(f"❌ Missing dependency: {e}")
        return False

def check_database():
    \"\"\"Check database connection\"\"\"
    db_url = os.getenv('DATABASE_URL')
    if not db_url:
        print("⚠️  No database configured")
        return True

    try:
        # Add database connection test here
        print("✅ Database connection OK")
        return True
    except Exception as e:
        print(f"❌ Database connection failed: {e}")
        return False

def check_application():
    \"\"\"Check if application is running\"\"\"
    port = os.getenv('PORT', '8000')
    host = os.getenv('HOST', 'localhost')

    try:
        response = requests.get(f"http://{host}:{port}/health", timeout=5)
        if response.status_code == 200:
            print("✅ Application is running")
            return True
    except requests.exceptions.ConnectionError:
        print("⚠️  Application not running (this is OK during setup)")
        return True
    except Exception as e:
        print(f"❌ Application health check failed: {e}")
        return False

def main():
    print("🏥 Health Check Starting...")

    checks = [
        check_env_file,
        check_dependencies,
        check_database,
        check_application
    ]

    all_passed = True
    for check in checks:
        if not check():
            all_passed = False

    if all_passed:
        print("\\n✅ All health checks passed!")
        sys.exit(0)
    else:
        print("\\n❌ Some health checks failed!")
        sys.exit(1)

if __name__ == "__main__":
    main()
"""

    def generate_troubleshooting(self, technologies: list) -> str:
        """Generuje TROUBLESHOOTING.md"""
        return """# 🔧 Troubleshooting Guide

## Common Issues

### 1. Application Won't Start

**Problem**: `ModuleNotFoundError` or import errors
```bash
# Solution: Install dependencies
pip install -r requirements.txt

# Or recreate virtual environment
rm -rf venv
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

**Problem**: `Permission denied` errors
```bash
# Solution: Fix permissions
chmod +x setup.sh run.sh
```

### 2. Database Connection Issues

**Problem**: `Connection refused` to database
```bash
# Check if database is running
docker-compose up postgres

# Or start local PostgreSQL
sudo systemctl start postgresql
```

**Problem**: `Authentication failed`
```bash
# Check .env file database credentials
cat .env | grep DB_

# Reset database password if needed
```

### 3. Port Already in Use

**Problem**: `Address already in use`
```bash
# Find what's using the port
lsof -i :8000

# Kill the process
kill -9 <PID>

# Or use different port
export PORT=8001
```

### 4. Environment Variables

**Problem**: Configuration not loading
```bash
# Check .env file exists
ls -la .env

# Verify variables are set
python -c "import os; print(os.getenv('SECRET_KEY'))"
```

### 5. Docker Issues

**Problem**: Docker build fails
```bash
# Clean Docker cache
docker system prune -a

# Rebuild without cache
docker build --no-cache .
```

**Problem**: Container exits immediately
```bash
# Check logs
docker logs <container_name>

# Run interactive shell
docker run -it <image_name> /bin/bash
```

## Health Check Commands

```bash
# Basic health check
python healthcheck.py

# Check all services
docker-compose ps

# View logs
docker-compose logs -f app
```

## Performance Issues

### High Memory Usage
```bash
# Monitor memory
htop
docker stats

# Optimize Python
export PYTHONUNBUFFERED=1
```

### Slow Response Times
```bash
# Enable debug mode
export DEBUG=True

# Check database queries
# Add logging to your database calls
```

## Getting Help

1. Check application logs: `tail -f app.log`
2. Run health check: `python healthcheck.py`
3. Verify environment: `cat .env`
4. Test manually: `curl http://localhost:8000/health`

## Emergency Recovery

```bash
# Complete reset
docker-compose down -v
rm -rf venv .env
cp .env.example .env
./setup.sh
```
"""

    def inception(self, problem: str) -> Dict:
        """Główna funkcja - wykonuje wszystkie 3 poziomy"""
        print(f"🌀 Inception starting for: {problem}")

        # Level 1: LIMBO
        print("📊 Level 1: LIMBO - Meta Architecture...")
        limbo_result = self.limbo(problem)
        print(f"   Components: {limbo_result.get('components', [])}")

        # Level 2: DREAM  
        print("🎭 Level 2: DREAM - Solution Design...")
        dream_result = self.dream(limbo_result)
        print(f"   Architecture: {dream_result.get('architecture', 'N/A')}")

        # Level 3: REALITY
        print("🌍 Level 3: REALITY - Implementation...")
        reality_result = self.reality(dream_result)
        print(f"   Files: {list(reality_result.get('files', {}).keys())}")

        return {
            "problem": problem,
            "limbo": limbo_result,
            "dream": dream_result,
            "reality": reality_result
        }


    def simple_cli(self, prompt: str = None):
        """Prosty CLI interface"""
        print("🌀 Simple Dream Architect")
        print("=" * 30)

        # Sprawdź połączenie z Ollama
        architect = SimpleDreamArchitect()
        try:
            test = architect.ask_ollama("test")
            print("✅ Ollama connection: OK")
        except:
            print("❌ Ollama connection: FAILED")
            print("   Make sure Ollama is running: ollama serve")
            return

        while True:
            problem = input("\n🎯 Describe your problem (or 'quit'): ").strip()

            if problem.lower() in ['quit', 'exit', 'q']:
                print("👋 Goodbye!")
                break

            if not problem:
                continue

            # Wykonaj inception
            result = architect.inception(problem)

            # Pokaż rezultaty
            print("\n" + "=" * 50)
            print("📋 RESULTS:")
            print("=" * 50)

            print("\n🏗️ ARCHITECTURE:")
            print(f"   {result['dream'].get('architecture', 'N/A')}")

            print("\n💻 TECHNOLOGIES:")
            for tech in result['dream'].get('technologies', []):
                print(f"   • {tech}")

            print("\n📁 GENERATED FILES:")
            for filename, content in result['reality'].get('files', {}).items():
                print(f"\n--- {filename} ---")
                print(content[:200] + "..." if len(content) > 200 else content)

            # Auto-save z opcjami
            save_choice = input("\n💾 Save files? (y/auto/custom/n): ").lower()

            if save_choice in ['y', 'yes', 'auto']:
                saved_files = self.save_files(result, auto_name=True)
                for filepath in saved_files:
                    print(f"   ✅ Saved: {filepath}")

            elif save_choice in ['custom', 'c']:
                project_name = input("📁 Project name: ").strip() or "project"
                saved_files = self.save_files(result, project_name=project_name)
                for filepath in saved_files:
                    print(f"   ✅ Saved: {filepath}")

    def save_files(self, result: Dict, project_name: str = None, auto_name: bool = False) -> List[str]:
        """Zapisuje wygenerowane pliki do dysku"""
        import os
        from datetime import datetime

        # Określ nazwę projektu
        if auto_name:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            project_name = f"dream_project_{timestamp}"
        elif not project_name:
            project_name = "output"

        # Stwórz katalog projektu
        project_dir = os.path.join("projects", project_name)
        os.makedirs(project_dir, exist_ok=True)

        saved_files = []
        files = result.get('reality', {}).get('files', {})

        # Zapisz pliki kodu
        for filename, content in files.items():
            filepath = os.path.join(project_dir, filename)

            # Stwórz subdirectories jeśli potrzebne
            os.makedirs(os.path.dirname(filepath), exist_ok=True)

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            saved_files.append(filepath)

        # Zapisz metadata projektu
        metadata = {
            "problem": result.get('problem', ''),
            "timestamp": datetime.now().isoformat(),
            "architecture": result.get('dream', {}).get('architecture', ''),
            "technologies": result.get('dream', {}).get('technologies', []),
            "components": result.get('limbo', {}).get('components', []),
            "files": list(files.keys())
        }

        metadata_file = os.path.join(project_dir, "project_info.json")
        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
        saved_files.append(metadata_file)

        # Stwórz README
        readme_content = self.generate_readme(result)
        readme_file = os.path.join(project_dir, "README.md")
        with open(readme_file, 'w', encoding='utf-8') as f:
            f.write(readme_content)
        saved_files.append(readme_file)

        return saved_files

    def generate_readme(self, result: Dict) -> str:
        """Generuje README.md dla projektu"""
        problem = result.get('problem', 'Unknown Problem')
        architecture = result.get('dream', {}).get('architecture', 'No architecture description')
        technologies = result.get('dream', {}).get('technologies', [])
        components = result.get('limbo', {}).get('components', [])
        files = list(result.get('reality', {}).get('files', {}).keys())

        readme = f"""# {problem.title()}

## Problem Description
{problem}

## Architecture
{architecture}

## Technologies Used
{chr(10).join(f"- {tech}" for tech in technologies)}

## Components
{chr(10).join(f"- {comp}" for comp in components)}

## Generated Files
{chr(10).join(f"- `{file}`" for file in files)}

## Setup Instructions

1. Install dependencies:
```bash
pip install -r requirements.txt  # if exists
```

2. Run the application:
```bash
python main.py  # or appropriate entry point
```

## Generated by Dream Architect
This project was automatically generated using the Dream Architect system.

- **Generation Time**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Levels Used**: LIMBO → DREAM → REALITY
"""
        return readme


# Enhanced save functions
def save_solution(problem: str, auto_save: bool = True) -> List[str]:
    """Generuje i automatycznie zapisuje rozwiązanie"""
    architect = SimpleDreamArchitect()
    result = architect.inception(problem)

    if auto_save:
        return architect.save_files(result, auto_name=True)
    return []


def batch_generate(problems: List[str], output_dir: str = "batch_projects") -> Dict[str, List[str]]:
    """Generuje rozwiązania dla wielu problemów na raz"""
    import os

    os.makedirs(output_dir, exist_ok=True)
    architect = SimpleDreamArchitect()
    results = {}

    for i, problem in enumerate(problems, 1):
        print(f"\n🌀 Processing {i}/{len(problems)}: {problem[:50]}...")

        try:
            result = architect.inception(problem)
            project_name = f"project_{i:02d}_{problem[:20].replace(' ', '_')}"
            project_name = "".join(c for c in project_name if c.isalnum() or c in '_-')

            saved_files = architect.save_files(result, project_name=project_name)
            results[problem] = saved_files
            print(f"   ✅ Saved to: projects/{project_name}")

        except Exception as e:
            print(f"   ❌ Error: {str(e)}")
            results[problem] = []

    return results


def list_projects() -> List[str]:
    """Lista wygenerowanych projektów"""
    import os

    if not os.path.exists("projects"):
        return []

    projects = []
    for item in os.listdir("projects"):
        project_path = os.path.join("projects", item)
        if os.path.isdir(project_path):
            projects.append(item)

    return sorted(projects)


def show_project_info(project_name: str):
    """Pokazuje informacje o projekcie"""
    import os

    info_file = os.path.join("projects", project_name, "project_info.json")

    if not os.path.exists(info_file):
        print(f"❌ Project {project_name} not found")
        return

    with open(info_file, 'r', encoding='utf-8') as f:
        info = json.load(f)

    print(f"\n📁 Project: {project_name}")
    print(f"🎯 Problem: {info.get('problem', 'N/A')}")
    print(f"🕒 Created: {info.get('timestamp', 'N/A')}")
    print(f"🏗️ Architecture: {info.get('architecture', 'N/A')}")
    print(f"💻 Technologies: {', '.join(info.get('technologies', []))}")
    print(f"📄 Files: {', '.join(info.get('files', []))}")


# Enhanced CLI with project management
def enhanced_cli():
    """Enhanced CLI z project management"""
    print("🌀 Dream Architect Pro")
    print("=" * 30)

    # Sprawdź połączenie z Ollama
    architect = SimpleDreamArchitect()
    try:
        test = architect.ask_ollama("test")
        print("✅ Ollama connection: OK")
    except:
        print("❌ Ollama connection: FAILED")
        return

    # Pokaż istniejące projekty
    projects = list_projects()
    if projects:
        print(f"\n📁 Existing projects ({len(projects)}):")
        for project in projects[-5:]:  # Show last 5
            print(f"   • {project}")
        if len(projects) > 5:
            print(f"   ... and {len(projects) - 5} more")

    while True:
        print("\n" + "=" * 50)
        print("Commands:")
        print("  dream <problem>  - Generate new solution")
        print("  batch           - Generate multiple solutions")
        print("  list            - List all projects")
        print("  show <project>  - Show project info")
        print("  quit            - Exit")

        command = input("\n🎯 Enter command: ").strip()

        if command.lower() in ['quit', 'exit', 'q']:
            print("👋 Goodbye!")
            break

        parts = command.split(None, 1)
        cmd = parts[0].lower() if parts else ""

        if cmd == "dream" and len(parts) > 1:
            problem = parts[1]
            result = architect.inception(problem)

            # Show results
            print("\n" + "=" * 50)
            print("📋 RESULTS:")
            print("=" * 50)

            print(f"\n🏗️ ARCHITECTURE:")
            print(f"   {result['dream'].get('architecture', 'N/A')}")

            print(f"\n💻 TECHNOLOGIES:")
            for tech in result['dream'].get('technologies', []):
                print(f"   • {tech}")

            print(f"\n📁 GENERATED FILES:")
            for filename in result['reality'].get('files', {}):
                print(f"   • {filename}")

            # Auto-save
            saved_files = architect.save_files(result, auto_name=True)
            print(f"\n💾 Auto-saved to:")
            for filepath in saved_files:
                print(f"   ✅ {filepath}")

        elif cmd == "batch":
            problems = []
            print("\nEnter problems (empty line to finish):")
            while True:
                problem = input("  > ").strip()
                if not problem:
                    break
                problems.append(problem)

            if problems:
                results = batch_generate(problems)
                print(f"\n✅ Generated {len([r for r in results.values() if r])} projects")

        elif cmd == "list":
            projects = list_projects()
            if projects:
                print(f"\n📁 Projects ({len(projects)}):")
                for project in projects:
                    print(f"   • {project}")
            else:
                print("\n📁 No projects found")

        elif cmd == "show" and len(parts) > 1:
            show_project_info(parts[1])

        else:
            print("❌ Unknown command or missing arguments")


# Example usage
if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        # Command line usage
        problem = " ".join(sys.argv[1:])
        result = save_solution(problem)

        print("Generated files:")
        for filename, content in result['reality'].get('files', {}).items():
            print(f"\n=== {filename} ===")
            print(content)
    else:
        # Interactive CLI
        enhanced_cli()